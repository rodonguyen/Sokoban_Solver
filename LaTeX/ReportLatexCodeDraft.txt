\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{hyperref}

\hypersetup{
    colorlinks=true,
    urlcolor=blue,
    }

\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
            
        \Huge
        \textbf{CAB320 Assignment 1: Sokoban}
            
        \vspace{0.5cm}
        \LARGE
        Intelligent Search â€“ Motion Planning in a Warehouse
            
        \vspace{1.5cm}
            
        \textbf{Mitchell Egan}
        n10210776
        
        \textbf{Jaydon Gunzburg}
        n10396489       
        
        \textbf{Rodo Nguyen}
        n10603280
        
        \small
        \vspace{1.5cm}
        \textbf{Abstract}
        
        Sokoban is a 2D Japanese puzzle game created in 1981 in which the player, a warehouse worker, must move a number of boxes to goal positions located around the warehouse; without getting any stuck. This version of Sokoban includes the added complexity of having weighted boxes, making the cost of moving a box equal to it's weight (+1 for moving).
        {\newline}
        {\newline}
        Our team has designed and implemented a Sokoban solver using the popular A* search algorithm, with \( ???? \) time complexity and \( O(b^d) \) space complexity. The algorithm determines if a warehouse is possible and if so, it returns the optimal path the player must take to solve the puzzle, along with the cost of that sequence. Of the 108 example warehouses, the shortest execution time was found to be ???? for warehouse ???, while the longest was ??? for warehouse ???.
            
        \LARGE
        \vfill
            
        \vspace{0.8cm}
            
        \includegraphics[width=0.4\textwidth]{QUTlogo}
            
        \Large
        School of Electrical Engineering and Robotics\\
        01/05/2021
            
    \end{center}
\end{titlepage}

\newpage

\section{Implementation}
An abstract \textit{problem class} and compatible A* solver written in python has been supplied. Initialisation, definition of actions, results of actions, a goal test method, path cost and heuristic function are all defined within this class to be used in conjunction with the solver. First, the \textit{problem class} constructor is initialised by defining both the starting state and goal state, along with the taboo cells of the warehouse, used to asses possible actions at each node of the search graph. The path cost method in a classic version of Sokoban would always be 1, to move from any valid state to another. In this weighted version, the path cost includes the weight of a box that could be pushed during such action and such, influences the priority queuing of A*.

To ensure our solution is robust to fatal errors and edge cases, unit test classes and a function for checking action sequences was also written. 

\subsection{Identification of Taboo Cells}
A cell is classified as taboo if the cell is a corner and not a target, or all cells between two corners along a wall, if no targets exist along that wall. In general terms, a taboo cell is one that if a box is pushed onto, the puzzle becomes impossible to solve.
The process for locating all taboo cells in a warehouse is as follows:
\begin{enumerate}
    \item Determine cells inside the warehouse:{\newline}
    Using a recursive flood-fill algorithm adopted from the Wikipedia entry on \href{https://en.wikipedia.org/wiki/Flood_fill}{Flood fill}. The algorithm starts from the player's initial position and runs until walls are found, resulting in finding all cells on the inside of the warehouse.
    \item Determine corner cells inside the warehouse:{\newline}
    For inside cells, a cell is a corner if it has at least 2 cells directly adjacent to it and those 2 cells are diagonally adjacent to each other.
    \item Pair corners up:{\newline}
    All the inside corners are then put into a set of corner pairs, such that they are pairs if they lie on the same row or column of the warehouse.
    \item Travel between corner pairs and mark taboo cells:{\newline}
    Traverse between each pair of corners, checking if both of the two walls that could exist adjacent to the travel direction break for more than two blocks, or if there is only one wall, that it doesn't break for more than one block. Once traversed, if no goals were found, all the traversed cells are taboo. Every corner that isn't also a goal is also taboo.
\end{enumerate}

\subsection{State Representation}
The most obvious state representation would simply be the entire ware house as a string. This method, however, is computationally wasteful as each time the state is used the entire warehouse string must be parsed. Only dynamic elements of the warehouse are required for the operations performed with and on the state during any search algorithm (where walls and taboo cells are used to determine possible moves - what a node expands to). For this reason, the warehouse state representation is simply a nested tuple containing the player's and the boxes' coordinates:
\[ state = ( (warehouse.player), (warehouse.boxes_1),... (warehouse.boxes_n) ) \]

\subsection{Heuristics [Rodo to implement]}

For our heuristic function, firstly, the program calculates the Manhattan distances from a box to all available targets and get the \textit{minimum one}. It does the same to all other boxes and return the \textit{sum of these minimum distances} as the final value of our heuristic function.  
% 
The heuristic function used for guiding A* returns the sum of all manhattan distances for each box to it's closest target.
%
The Manhattan distance formula can be expressed as:
\[ manhattan\_dist = |x_2-x_1|+|y_2-y_1| \] where \( (x_1,y_1), (x_2, y_2) \) are the coordinates of a box and a target respectively.
\newline
\newline
The admissibility of this heuristic function is when utilizing Manhattan distance function, it only takes into account the boxes and their closest targets in a warehouse. Thus, every other obstacles (e.g. another box or wall) are ignored and boxes assumably can be moved straight towards the targets along x and y axes. For that reason, it is certain that:
%
Ensuring only the closest target to each box is used and ignoring walls when calculating Manhattan distances, underestimates the true path cost each iteration. Doing so, guarantees the heuristic is admissible such that:
%
\[ 0 \le h(s) \le h^*(s) \]
where \(s\) is a state of a warehouse, \(h\) is the heuristic function, \(h*\) is the true cost from s to a nearest goal.
\newline
\newline
[ consistency......? ]

\section{Testing Methodology [Rodo to implement]}

To ensure code functioning properly and giving warnings about any incorrect behaviours during the implementation process, unittest.TestCase module provides a solution for this and also automate testing with GitHub actions in every Push to our GitHub repository.
\newline
3 main test classes are implemented in our project, namely TestTabooCells, TestSokobanPuzzle, and TestCheckElemActionSeq. Each of them contains one or more test cases that are responsible for testing related essential functions (as their name suggests) and each \_\_init\_\_ function will load a warehouse which will then be called in the test cases.

\section{Performance and Limitations [J to implement]}
\subsection{Runtime and Cost Comparison}

\subsection{Manhattan Distance Evaluation}
A* is only as good as its heuristic; underestimating a heuristic as close to the true cost of an optimal path guarantees admissibility, while ensuring high efficiency. For this reason, ideally, the manhattan distance between two points should consider walls and return the true manhattan path through the warehouse between the points. To implement this however, the program would be required to run another search algorithm such as Breath-First-Search, just to find this ideal path.

Considering the heuristic is designed to make A* more efficient, it becomes redundant to utilise this method as it creates a lot more computation to perform. For this reason, the decision was made to not include walls in the manhattan distance calculation; creating a sub-optimal path estimation but with a computationally cheap calculation. 

\subsection{Iterative Deepening A*}

\end{document}